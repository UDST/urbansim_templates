from __future__ import print_function

import re

import orca

from urbansim_templates import modelmanager, __version__
from urbansim_templates.utils import merge_tables


@modelmanager.template
class ColumnFromBroadcast():
    """
    Template to register a column of derived data with Orca, generated by mapping values 
    from another table via one or more join keys. Values will be calculated lazily, only 
    when the column is needed for a specific operation. 

    All the parameters can also be set as properties after creating the template 
    instance.
    
    Parameters
    ----------
    column_name : str, optional
        Name of Orca column to be created. Required before running.
    
    destination_table : str, optional
        Name of Orca table the column will be associated with. Required before running.
    
    source_table : str or list of str, optional
        Name of Orca table containing the original data. Required before running. Must be 
        joinable to the destination table using standard ModelManager schema rules: there 
        should be a join key column in the destination table with the same name as the 
        source table's index. Joining on multi-indexes is supported. You may also provide 
        a source *chain* here, listing multiple tables. These will be combined using 
        :func:`~urbansim_templates.utils.merge_tables()` before generating the new 
        column. If you provide a list, the first item must be the destination table.
    
    source_column : str, optional
        Name of column in the source table to map to the destination table. Required 
        before running. You may also provide an expression here, describing operations on 
        one or more columns from the source and destination tables. Same expression rules 
        as :mod:`~urbansim_templates.data.ColumnFromExpression()`.

    data_type : str, optional
        Python type or ``numpy.dtype`` to cast the column's values into.
    
    missing_values : str or numeric, optional
        Value to use for rows that would otherwise be missing.
    
    cache : bool, default False
        Whether to cache column values after they are calculated.
    
    cache_scope : 'step', 'iteration', or 'forever', default 'forever'
        How long to cache column values for (ignored if ``cache`` is False).
    
    name : str, optional
        Name of the template instance and associated model step. 
    
    tags : list of str, optional
        Tags to associate with the template instance.
    
    autorun : bool, default True
        Whether to run automatically when the template instance is registered with 
        ModelManager.
    
    """
    def __init__(self, 
            column_name = None, 
            destination_table = None, 
            source_table = None, 
            source_column = None, 
            data_type = None, 
            missing_values = None, 
            cache = False, 
            cache_scope = 'forever', 
            name = None,
            tags = [], 
            autorun = True):
        
        # Template-specific params
        self.column_name = column_name
        self.destination_table = destination_table
        self.source_table = source_table
        self.source_column = source_column
        self.data_type = data_type
        self.missing_values = missing_values
        self.cache = cache
        self.cache_scope = cache_scope
        
        # Standard params
        self.name = name
        self.tags = tags
        self.autorun = autorun
        
        # Automatic params
        self.template = self.__class__.__name__
        self.template_version = __version__
    
    
    @classmethod
    def from_dict(cls, d):
        """
        Create an object instance from a saved dictionary representation.
        
        Parameters
        ----------
        d : dict
        
        Returns
        -------
        Table
        
        """
        obj = cls(
            column_name = d['column_name'],
            destination_table = d['destination_table'],
            source_table = d['source_table'],
            source_column = d['source_column'],
            data_type = d['data_type'],
            missing_values = d['missing_values'],
            cache = d['cache'],
            cache_scope = d['cache_scope'],
            name = d['name'],
            tags = d['tags'],
            autorun = d['autorun']
        )
        return obj
    
    
    def to_dict(self):
        """
        Create a dictionary representation of the object.
        
        Returns
        -------
        dict
        
        """
        d = {
            'template': self.template,
            'template_version': self.template_version,
            'name': self.name,
            'tags': self.tags,
            'autorun': self.autorun,
            'column_name': self.column_name,
            'destination_table': self.destination_table,
            'source_table': self.source_table,
            'source_column': self.source_column,
            'data_type': self.data_type,
            'missing_values': self.missing_values,
            'cache': self.cache,
            'cache_scope': self.cache_scope,
        }
        return d
    
    
    def run(self):
        """
        Run the template, registering a column of derived data with Orca.
        
        Requires values to be set for ``column_name``, ``destination_table``, 
        ``source_table``, and ``source_column``.
        
        Returns
        -------
        None
        
        """
        if self.column_name is None:
            raise ValueError("Please provide a column name")
        
        if self.destination_table is None:
            raise ValueError("Please provide a destination table")
        
        if self.source_table is None:
            raise ValueError("Please provide a source table")
        
        if self.source_column is None:
            raise ValueError("Please provide a source column")
        
        tables = [self.destination_table, self.source_table]
        
        if isinstance(self.source_table, list):
            tables = self.source_table
            
        # TO DO: move this to a utility
        cols = re.findall('[a-zA-Z_][a-zA-Z0-9_]*(?!\()', self.source_column)
        
        @orca.column(table_name = self.destination_table, 
                     column_name = self.column_name, 
                     cache = self.cache, 
                     cache_scope = self.cache_scope)
        def orca_column():
            df = merge_tables(tables, columns=cols)
            series = df.eval(self.source_column)
            
            if self.missing_values is not None:
                series = series.fillna(self.missing_values)
            
            if self.data_type is not None:
                series = series.astype(self.data_type)
            
            return series
        
    